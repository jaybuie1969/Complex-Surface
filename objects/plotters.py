import cv2
import json
import numpy as np
import matplotlib.pyplot as plt
import os

from matplotlib import cm
from matplotlib.colors import LightSource
from pathlib import Path
from re import split
from typing import Dict, List, Tuple

class FunctionPlotter:
	# This class is the first, generic class for plotting a surface
	# As it gets larger with more methods, it may be extrapolated into subclasses

	# Set the default expected location of the surface data file that will e read in and initialize the objects into which it will be laoded
	input_file:Path = "./json/output.json"
	ranges:List[Dict] = None
	frames:np.ndarray = None

	minima:np.ndarray = None
	maxima:np.ndarray = None

	color_scheme = None

	json_data:Dict = None

	# This is the size of the generated images in inches, it is currently hard-coded and not able to be overwritten
	# That may need to change in the fouture
	x_size:float = 10

	# Set the default assumed locations where images and videos from this plotter object will be saved
	image_output_path:Path = Path("./images")
	video_output_path:Path = Path("./videos")

	def __init__(self, **kwargs):
		"""
		This object initialization method primarily looks for overriding the paths for the input surface data file and the output directories for images and videos generated by this object
		"""

		if (("image_output_path" in kwargs) and (kwargs["image_output_path"] != "")):
			if (os.path.isdir(kwargs["image_output_path"])):
				self.image_output_path = Path(kwargs["image_output_path"])
			else:
				raise Exception("Unknown image output path " + kwargs["image_output_path"])

		if (("video_output_path" in kwargs) and (kwargs["video_output_path"] != "")):
			if (os.path.isdir(kwargs["video_output_path"])):
				self.video_output_path = Path(kwargs["video_output_path"])
			else:
				raise Exception("Unknown video output path " + kwargs["video_output_path"])

		if (("input_file" in kwargs) and (kwargs["input_file"] != "")):
			input_file = None
			input_list = split(r"/|\\", kwargs["input_file"])

			if (len(input_list) == 1):
				input_file = "./json/" + kwargs["input_file"]
			elif (os.path.isdir("/". join(input_list[0 : -1]))):
				input_file = kwargs["input_file"]
			else:
				raise Exception("Unknown input file " + input_file)

			if (os.path.isfile(input_file)):
				self.input_file = Path(input_file)
			else:
				raise Exception("Unknown input file " + input_file)
		elif (not os.path.isfile(self.input_file)):
			raise Exception("Unknown input file " + self.input_file)
		else:
			self.input_file = Path(self.input_file)

		if (("color_scheme" in kwargs) and (kwargs["color_scheme"] != "")):
			try:
				self.color_scheme = cm.get_cmap(kwargs["color_scheme"])
			except:
				raise Exception("Unknown color scheme " + kwargs["color_scheme"])

		with open(self.input_file) as f:
			json_data:Dict = json.load(f)
			self.ranges = json_data["ranges"]
			self.frames = np.array(json_data["frames"])

			if (len(self.frames.shape) >= 2):
				self.minima = np.zeros(self.frames.shape[1])
				self.maxima = np.zeros(self.frames.shape[1])

				for i in range(0, self.frames.shape[1]):
					self.minima[i] = np.min(self.frames[ : , i, : , : ])
					self.maxima[i] = np.max(self.frames[ : , i, : , : ])

	def generate_frame_arrays(self, frame_number:int, output_element:int) -> Tuple[np.array, np.array, np.array]:
		"""
		This method retrieves the desired x, y and z elements to be used when generating an image of a surface from a single frame of input data
		Since the surface data set can be huper dimensional, it is assumed that the x and y elements are the first two, and the desired z element can be any of the
		other elements as per the output_elemest argument

		Parameters
		----------
		frame_number : int
			The array index number of the frame of surface data that will be used to retrieve the x, y and z coordinate sets
		output_element : int
			The index number of an individual data point element that will be retrieved from the desired frame as the z coordinate set being returned

		Returns
		-------
		Tuple[numpy.array, numpy.array, numpy.array]
			The x, y and z coordinates sets that will be used to generate an image of a surface
		"""

		x = None
		y = None
		z = None

		if (
			(self.frames is not None)
			and (len(self.frames.shape) > 0)
			and (frame_number >= 0)
			and (frame_number <= self.frames.shape[0])
			and (output_element >= 0)
			and (output_element <= self.frames.shape[1])
		):
			x = self.frames[frame_number, 0]
			y = self.frames[frame_number, 1]
			z = self.frames[frame_number, output_element]

		return (x, y, z)

	def write_frame(
		self,
		frame_number:int,
		output_element:int=None,
		projection_basis:np.ndarray=None,
		elevation:float=0,
		azimuth:float=0,
		light_elevation:float=0,
		light_azimuth:float=0,
		output_file:str=None
	):
		"""
		This method creates an image using a single frame from the input data and writes it out as a PNG file
		This method can be called directly by the application that instantiated this object, but it is primarily used to do the heavy lifting by
		other methods that need to generate multiple images

		Parameters
		----------
		frame_number : int
			The index of the desired frame of input_data to be used to generate the image
		output_element : int, default None
			The index of the element within an individual point to be used as the z coordinate set for the surface image being generated
			Either the output_element or the projection_basis argument must be present and not None
			If both the output_element and projection_basis arguments are present and valid, output_element is used and projection_basis is ignored
		projection_basis : numpy.ndarray, default None
			A basis vector set which will be used to transform the data frame's points before generating the surface
			When this is used, the third element in each data point is automatically used for the z coordinate, any other higher dimension values are "forgotten" after the transformation
			The projection_basis argument is used only if the output_element argument is None
		elevation : float, default 0
			The angle, in degrees above or below the xy plane, of the camera position for the image generated
		azumuth  float, default 0
			The angle, in degrees around the xy plane, of the camera position for the image generated
		light_elevation : float, default 0
			The angle, in degrees above or below the xy plane, of the light source illuminating the surface
		light_azumuth : float, default 0
			The angle, in degrees around the xy plane, of the light source illuminating the surface
		output_file : str default None
			The desired name of the output file for the surface image generated

		Returns
		-------
		None
			The output of this method call is a PNG image written to the file system
		"""

		x = None
		x_min_max = None

		y = None
		y_min_max = None

		z = None
		z_min_max = None

		if ((frame_number is None) or (type(frame_number) not in [float, int])):
			raise Exception("This method call either requires a frame_number argument (integer) between 0 and the highest index in the first part of the frames shape (" + str(self.frames.shape[0]) + " with this data set)")
		else:
			if (type(output_element) == float):
				frame_number = int(frame_number)

			if ((frame_number < 0) or (frame_number >= self.frames.shape[0])):
				raise Exception("This method call either requires a frame_number argument (integer) between 0 and the highest index in the first part of the frames shape (" + str(self.frames.shape[0]) + " in this case)")

		if ((output_element is None) and (projection_basis is None)):
			raise Exception("This method call either requires specifying a desired output_element (integer) or a projection_basis (numpy.ndarray)")
		elif (projection_basis is None):
			if (type(output_element) not in [float, int]):
				raise Exception("output_element must be a integer between 0 and the highest index of the first part of the desired frame's shape (" + str(self.frames[frame_number].shape[0]) + " with this data set)")
			else:
				if (type(output_element) == float):
					output_element = int(output_element)

				if ((output_element < 0) or (output_element >= self.frames[frame_number].shape[0])):
					raise Exception("output_element must be a integer between 0 and the highest index of the first part of the desired frame's shape (" + str(self.frames[frame_number].shape[0]) + " with this data set)")
				else:
					(x, y, z) = self.generate_frame_arrays(frame_number, output_element)
		elif (
			(type(projection_basis) != np.ndarray)
			or (len(projection_basis.shape) != 2)
			or (projection_basis.shape[0] != projection_basis.shape[1])
			or (projection_basis.shape[0] != self.frames[frame_number].shape[0])
		):
			raise Exception("projection_basis must be a square two-dimensional numpy array with each dimension the same as a point in the desired frame (" + str(self.frames[frame_number].shape[0]) + " with this data set)")
		else:
			projected = np.zeros(self.frames[frame_number].shape)
			for i in range(0, self.frames[frame_number].shape[1]):
				for j in range(0, self.frames[frame_number].shape[2]):
					projected[ : , i, j] = projection_basis.T @ self.frames[frame_number][ : , i, j]

			x = projected[0]
			y = projected[1]
			z = projected[2]

		# If this method call has made it this far without raising an exception, everything is good for generating the surface image, do that now

		# Initialize the figure object where the image will be generated
		figure = plt.figure(figsize=(self.x_size, (self.x_size * (self.ranges[1]["segments"] / self.ranges[0]["segments"]))))

		axis = figure.add_subplot( projection="3d")

		axis.set_xlim(self.minima[0], self.maxima[0])
		axis.set_ylim(self.minima[1], self.maxima[1])
		axis.set_zlim(np.min(self.minima[2 : ]), np.max(self.maxima[2 : ]))

		axis.view_init(elev=elevation, azim=azimuth)

		# Now, set the light source's location and generate the image
		# NOTE - right now, the color map used is hard-coded to viridis - this may change in the future
		ls = LightSource(azdeg=light_azimuth, altdeg=light_elevation)
		if (self.color_scheme is None):
			axis.plot_surface(x, y, z)
		else:
			axis.plot_surface(x, y, z, facecolors=ls.shade(z, cmap=self.color_scheme))

		# Make sure that the output_file argument contains a file name
		if (output_file is None):
			output_file = "frame_" + str(frame_number).zfill(6) + ".png"

		# Finally, save the image output file and clear out pyplot to free up memory
		plt.savefig(self.image_output_path / output_file)
		plt.close("all")

	def write_all_frames(self, output_element:int=None, projection_basis:np.array=None, elevation:float=0, azimuth:float=0, light_elevation:float=0, light_azimuth:float=0):
		"""
		This method generates images of every frame in the object's input_data and writes each one to an individual PNG file

		Parameters
		----------
		output_element : int, default None
			The index of the element within an individual point to be used as the z coordinate set for the surface image being generated
			Either the output_element or the projection_basis argument must be present and not None
			If both the output_element and projection_basis arguments are present and valid, output_element is used and projection_basis is ignored
		projection_basis : numpy.array, default None
			A basis vector set which will be used to transform the data frame's points before generating the surface
			When this is used, the third element in each data point is automatically used for the z coordinate, any other higher dimension values are "forgotten" after the transformation
			The projection_basis argument is used only if the output_element argument is None
		elevation : float
			The angle, in degrees above or below the xy plane, of the camera position for the image generated
		azumuth  float
			The angle, in degrees around the xy plane, of the camera position for the image generated
		light_elevation : float
			The angle, in degrees above or below the xy plane, of the light source illuminating the surface
		light_azumuth : float
			The angle, in degrees around the xy plane, of the light source illuminating the surface

		Returns
		-------
		None
			The output of this method call is the set of PNG images written to the file system
		"""

		if (
			(self.frames is not None)
			and (len(self.frames.shape) > 0)
			and (output_element >= 0)
			and (output_element <= self.frames.shape[1])
		):
			# All expected parameters are syntactically valid, iterate through all the frames of input_data and generate each one's image
			for i in range(self.frames.shape[0]):
				self.write_frame(i, output_element, projection_basis, elevation, azimuth, light_elevation, light_azimuth)

	def write_rotated_light(self, frame_number:int, output_element:int=None, projection_basis:np.array=None, to_rotate:str=None, other_angle:float=0, elevation:float=0, azimuth:float=0):
		"""
		This method generates multiple images of a single frame in the object's input_data and writes each one to an individual PNG file
		Each individual image generated has the light source rotated around either the elevation or azimuth of the image surface's xy plane
		This method call generates 360 different images, fully encircling the desired frame of image data
		It is primarily intended to be used as a test to see what illumination angles work best for a given surface

		Parameters
		----------
		frame_number : int
			The index of the desired frame of input_data to be used to generate the image
		output_element : int, default None
			The index of the element within an individual point to be used as the z coordinate set for the surface image being generated
			Either the output_element or the projection_basis argument must be present and not None
			If both the output_element and projection_basis arguments are present and valid, output_element is used and projection_basis is ignored
		projection_basis : numpy.array, default None
			A basis vector set which will be used to transform the data frame's points before generating the surface
			When this is used, the third element in each data point is automatically used for the z coordinate, any other higher dimension values are "forgotten" after the transformation
			The projection_basis argument is used only if the output_element argument is None
		to_rotate : str
			The specified angle, either elevation or azimuth, through which the light source will be rotated to generated this set of images
		other_angle : float
			The other angle, in degrees above, below or around the xy plane, of the light source illuminating the surface
			Whether this is the elevation or azimuth angle depends on the to_rotate argument, this is the other angle from the one specified in to_rotate
		elevation : float
			The angle, in degrees above or below the xy plane, of the camera position for the image generated
		azumuth  float
			The angle, in degrees around the xy plane, of the camera position for the image generated

		Returns
		-------
		None
			The output of this method call is the set of PNG images written to the file system
		"""

		if (
			(self.json_data is not None)
			and (len(self.json_data) > 0)
			and (frame_number >= 0)
			and (output_element >= 2)
			and (len(self.json_data["frames"][0]) > 0)
			and (type(self.json_data["frames"][0][0]) == list)
			and (len(self.json_data["frames"][0][0]) > output_element)
		):
			# By default, rotate the azimuth of the light source, only rotate the elevation if "elevation" is explicitly stated
			if (to_rotate != "elevation"):
				to_rotate = "azimuth"

			# All the fields are syntactically valid, now iterate around a full circle and generated the desired set of images
			for rotation_angle in range(0, 360):
				if (to_rotate == "azimuth"):
					self.write_frame(frame_number, output_element, projection_basis, elevation, azimuth, rotation_angle, other_angle, "frame_" + str(frame_number).zfill(6) + "_azimuth_" + str(rotation_angle).zfill(3) + "_" + str(other_angle).zfill(3) + ".png")
				else:
					self.write_frame(frame_number, output_element, projection_basis, elevation, azimuth, other_angle, rotation_angle, "frame_" + str(frame_number).zfill(6) + "_elevation_" + str(rotation_angle).zfill(3)  + "_" + str(other_angle).zfill(3)+ ".png")

	def write_video(self, compute_frames:bool, output_element:int=None, projection_basis:np.array=None, output_file:str=None, elevation:float=0, azimuth:float=0, light_elevation:float=0, light_azimuth:float=0):
		"""
		This method generates an MP4 video from images of every frame in the object's input_data

		Parameters
		----------
		compute_frames : bool
			A yes/no flag indicating whether or not the individual image frames need to be generated or already exist
		output_element : int, default None
			The index of the element within an individual point to be used as the z coordinate set for the surface image being generated
			Either the output_element or the projection_basis argument must be present and not None
			If both the output_element and projection_basis arguments are present and valid, output_element is used and projection_basis is ignored
		projection_basis : numpy.array, default None
			A basis vector set which will be used to transform the data frame's points before generating the surface
			When this is used, the third element in each data point is automatically used for the z coordinate, any other higher dimension values are "forgotten" after the transformation
			The projection_basis argument is used only if the output_element argument is None
		output_file : str
			The desired name of the output file for the video generated
		elevation : float
			The angle, in degrees above or below the xy plane, of the camera position for the image generated
		azumuth  float
			The angle, in degrees around the xy plane, of the camera position for the image generated
		light_elevation : float
			The angle, in degrees above or below the xy plane, of the light source illuminating the surface
		light_azumuth : float
			The angle, in degrees around the xy plane, of the light source illuminating the surface

		Returns
		-------
		None
			The output of this method call is the set of MP4 video written to the file system
		"""

		if ((not compute_frames) or (output_element is not None)):
			generate_video = False

			if (compute_frames):
				# the individual frames need to be generated, do that now
				if (output_element >= 2):
					print(f"Computing frames for elevation={elevation}, azimuth={azimuth}")
					self.write_all_frames(output_element, projection_basis, elevation, azimuth, light_elevation, light_azimuth)
					generate_video = True
			else:
				generate_video = True

			if (generate_video):
				# All frame images are (presumably) ready to be written to a video, do that now

				# First, make sure that the output_file argument is populated and ends in "mp4"
				if ((output_file is not None) and (output_file != "")):
					output_list = output_file.split(".")
					if (len(output_list) == 1):
						output_file = output_file + ".mp4"
				else:
					output_file = "output.mp4"

				# Next, make sure that a full output file path exists and represents a file in an existing directory
				output_file_path:Path = None
				output_list = split(r"/|\\", output_file)
				if (len(output_list) == 1):
					output_file_path = Path(self.video_output_path / output_file)
				elif (os.path.isdir("/". join(output_list[0 : -1]))):
					output_file_path = Path(output_file)

				# Get all the individual frame image file names and sort them -- is assumed that the images names follow some sort of sequential naming convention
				images = [self.image_output_path / img for img in os.listdir(self.image_output_path)]
				images.sort()

				# Now initialize a VideoWriter object, specifying the output file, file format, frame rate and frame size
				# 24 frames per second is a hard-coded value, future development may allow this to be configurable
				# NOTE - self.x_size represents inches for the PNG image files generated, for MP4 videos, it needs to be multiplied by 100 (assuming 100 pixels per inch)
				video = cv2.VideoWriter(
					output_file_path,
					cv2.VideoWriter_fourcc(*"mp4v"),
					24,
					(
						int(self.x_size * 100),
						int(self.x_size * (self.ranges[1]["segments"] / self.ranges[0]["segments"]) * 100)
					)
				)

				# Now write each individual frame image file into the VideoWriter object and then close the file generated
				for image in images:
					video.write(cv2.imread(image))

				video.release()
		else:
			raise Exception("If video frames are to be computed, the output element must be selected")

	def write_video_rotated_light(self, frame_number:int, output_element:int=None, projection_basis:np.array=None, to_rotate:str=None, other_angle:float=0, output_file:str=None, elevation:float=0, azimuth:float=0):
		"""
		This method generates an MP4 video from images of a given frame in the object's input_data
		The generated video contains 360 frames rotating the light source full circle around the generated surface
		The video from this method call is intended to be used as a test to help see which light source location is best for a given surface

		Parameters
		----------
		frame_number : int
			The index of the desired frame of input_data to be used to generate the image
		output_element : int, default None
			The index of the element within an individual point to be used as the z coordinate set for the surface image being generated
			Either the output_element or the projection_basis argument must be present and not None
			If both the output_element and projection_basis arguments are present and valid, output_element is used and projection_basis is ignored
		projection_basis : numpy.array, default None
			A basis vector set which will be used to transform the data frame's points before generating the surface
			When this is used, the third element in each data point is automatically used for the z coordinate, any other higher dimension values are "forgotten" after the transformation
			The projection_basis argument is used only if the output_element argument is None
		to_rotate : str
			The specified angle, either elevation or azimuth, through which the light source will be rotated to generated this set of images
		other_angle : float
			The other angle, in degrees above, below or around the xy plane, of the light source illuminating the surface
			Whether this is the elevation or azimuth angle depends on the to_rotate argument, this is the other angle from the one specified in to_rotate
		output_file : str
			The desired name of the output file for the video generated
		elevation : float
			The angle, in degrees above or below the xy plane, of the camera position for the image generated
		azumuth  float
			The angle, in degrees around the xy plane, of the camera position for the image generated

		Returns
		-------
		None
			The output of this method call is the set of MP4 video written to the file system
		"""
		if (output_element is not None):
			generate_video = False

			if (output_element >= 2):
				# Before doing anything else, generate the data for all 360 images to be used in this video
				print(f"Computing frames for elevation={elevation}, azimuth={azimuth}")
				self.write_rotated_light(frame_number, output_element, projection_basis, to_rotate, other_angle, elevation, azimuth)
				generate_video = True

			if (generate_video):
				# Next, make sure that the output_file argument is populated with a file name
				if ((output_file is not None) and (output_file != "")):
					output_list = output_file.split(".")
					if (len(output_list) == 1):
						output_file = output_file + ".mp4"
				else:
					output_file = "output.mp4"

				# Now, make sure that the full intended destination path of the video file goes to an existing directory
				output_file_path:Path = None
				output_list = split(r"/|\\", output_file)
				if (len(output_list) == 1):
					output_file_path = Path(self.video_output_path / output_file)
				elif (os.path.isdir("/". join(output_list[0 : -1]))):
					output_file_path = Path(output_file)

				# Get all the individual frame image file names and sort them -- is assumed that the images names follow some sort of sequential naming convention
				images = [self.image_output_path / img for img in os.listdir(self.image_output_path)]
				images.sort()

				# Now initialize a VideoWriter object, specifying the output file, file format, frame rate and frame size
				# 24 frames per second is a hard-coded value, future development may allow this to be configurable
				# NOTE - self.x_size represents inches for the PNG image files generated, for MP4 videos, it needs to be multiplied by 100 (assuming 100 pixels per inch)
				video = cv2.VideoWriter(
					output_file_path,
					cv2.VideoWriter_fourcc(*"mp4v"),
					24,
					(
						self.x_size * 100,
						int(self.x_size * (self.ranges[1]["segments"] / self.ranges[0]["segments"]) * 100)
					)
				)

				# Now write each individual frame image file into the VideoWriter object and then close the file generated
				for image in images:
					video.write(cv2.imread(image))

				video.release()
		else:
			raise Exception("If video frames are to be computed, the output element must be selected")



class VectorPlotter:
	frames:np.ndarray = None
	x_size:float = 10
	image_output_path:Path = Path("./images")
	video_output_path:Path = Path("./videos")

	def __init__(self, frames:np.ndarray):
		self.frames = frames


	def write_frame(self, frame_number:int, elevation:float=0, azimuth:float=0, light_elevation:float=0, light_azimuth:float=0, output_file:str=None):
		print(frame_number)
		np.set_printoptions(precision=2)
		print(self.frames[0, : , : , frame_number])
		print(self.frames[1, : , : , frame_number])

		'''
		figure = plt.figure(figsize=(self.x_size, (self.x_size * (self.ranges[1]["segments"] / self.ranges[0]["segments"]))))
		axis = figure.add_subplot( projection="3d")
		axis.view_init(elev=elevation, azim=azimuth)

		ls = LightSource(azdeg=light_azimuth, altdeg=light_elevation)
		axis.plot_surface(x, y, z, facecolors=ls.shade(z, cmap=cm.viridis))

		if (output_file is None):
			output_file = "frame_" + str(frame_number).zfill(6) + ".png"

		plt.savefig(self.image_output_path / output_file)
		plt.close("all")
		'''
